module Demo.AutoOps where

    import qualified Daml.Trigger as T
    import Topl.Asset
    import Topl.Utils
    import Demo.Poll
    import DA.Optional (whenSome)
    import DA.List

    import Demo.Onboarding

    isConfirmed: SendStatus -> Bool
    isConfirmed New = False 
    isConfirmed Pending = False 
    isConfirmed (Sent {} ) = False 
    isConfirmed (FailedToSend {} ) = False 
    isConfirmed (Confirmed {}) = True

    initSession : T.Trigger ()
    initSession = T.Trigger with
        initialize = pure ()
        updateState = \_ -> pure ()
        rule = \operator -> do
            let nft = AssetCode
                            with
                                issuerAddress = "AUANVY6RqbJtTnQS1AFTQBjXMFYDknhV8NEixHFLmeZynMxVbp64"
                                version = 1
                                shortName = "TOPLNFT"
            demoPollShowResultsTuples <- T.query @DemoPollShowResults
            demoPollShowResults <- mapA
                                        (\x -> do
                                            signedAssetMintingTuples <- T.query @SignedAssetMinting
                                            res <- mapA
                                                (\y -> do
                                                    T.dedupExercise
                                                        (fst x)
                                                        (DemoPollShowResults_CaptureNFTAssetMinting (snd y) (fst y))
                                                    )
                                                (filter (\y -> ((snd y).assetCode == nft) && (isConfirmed (snd y).sendStatus)) signedAssetMintingTuples)                                        
                                            let theDemoPollShowResult = snd x
                                            someYesAssetBalanceRes <- T.queryContractKey @AssetBalanceResponse (theDemoPollShowResult.participant, theDemoPollShowResult.yesAddress, theDemoPollShowResult.assetCode)
                                            someNoAssetBalanceRes <- T.queryContractKey @AssetBalanceResponse (theDemoPollShowResult.participant, theDemoPollShowResult.noAddress, theDemoPollShowResult.assetCode) 
                                            someUserAssetBalanceRes <- T.queryContractKey @AssetBalanceResponse (theDemoPollShowResult.participant, theDemoPollShowResult.userAddress, nft) 
                                            whenSome someYesAssetBalanceRes (\yesAssetBalanceRes -> 
                                                                                    whenSome someNoAssetBalanceRes (\noAssetBalanceRes -> 
                                                                                        whenSome someUserAssetBalanceRes (\userAssetBalanceRes ->  
                                                                                            T.dedupExercise
                                                                                                (fst x)
                                                                                                (DemoPollShowResults_CaptureResult (snd yesAssetBalanceRes) (fst yesAssetBalanceRes) (snd noAssetBalanceRes) (fst noAssetBalanceRes) (snd userAssetBalanceRes) (fst userAssetBalanceRes))
                                                                                )))
                                        )
                                        demoPollShowResultsTuples
            demoPollCompletedTuples <- T.query @DemoPollCompleted
            demoPollCompleted <- mapA
                                    (\x -> do
                                        let theDemoPollCompleted = snd x
                                        completedTransferRequests <- T.query @SignedAssetTransfer
                                        let confirmedTransactions = (filter (\y -> ((snd y).requestor == theDemoPollCompleted.participant) && isConfirmed ((snd y).sendStatus)) completedTransferRequests)
                                        if (not (null confirmedTransactions)) then
                                            do
                                                (T.dedupExercise 
                                                    (fst x) 
                                                    (DemoPollCompleted_AskForBalance))
                                                (T.dedupExercise
                                                    (fst (head confirmedTransactions))
                                                    (SignedAssetTransfer_Archive))
                                        else
                                            pure ()
                                        )
                                    demoPollCompletedTuples
            demoPollVotedTuples <- T.query @DemoPollVoted
            demoPolls <- mapA
                            (\x -> do
                                let theDemoPollVoted = snd x
                                unsignedAssetTransferRequest <- T.query @UnsignedAssetTransferRequest
                                res <- mapA
                                    (\y -> do
                                        T.dedupExercise 
                                            (fst x) 
                                            (DemoPollVoted_CaptureSignRequest  (snd y) (fst y))
                                        )
                                    (filter (\y -> ((snd y).requestor == theDemoPollVoted.participant)) unsignedAssetTransferRequest)
                                pure ()
                                )
                            demoPollVotedTuples
            acceptedConnectionsTuples <- T.query @AcceptedConnection
            demoPolls <- mapA
                            (\x -> do
                                let theFirstConnection = snd x
                                signedAssetMintingTuples <- T.query @SignedAssetMinting
                                res <- mapA
                                    (\y -> do
                                        T.dedupExercise 
                                            (fst x) 
                                            (AcceptedConnection_StartPoll  (snd y) (fst y))
                                        )
                                    (filter (\y -> ((snd y).requestor == theFirstConnection.user) && (isConfirmed (snd y).sendStatus)) signedAssetMintingTuples)
                                pure ()
                                )
                            acceptedConnectionsTuples
            tuplesConnections <- T.query @ConnectionRequest
            -- let firstConnections = map fst tuplesConnections
            -- let firstConnectionsData = map snd tuplesConnections
            acceptConnectior <- mapA 
                                (\x -> 
                                    T.dedupExercise 
                                        (fst x)
                                        ConnectionRequest_Accept
                                        ) 
                            tuplesConnections 

            pure ()
        registeredTemplates = T.AllInDar
        heartbeat = None
